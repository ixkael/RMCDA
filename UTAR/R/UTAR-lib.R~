#############################################################################
#
# Copyright Boris Leistedt, 2010-2011  
# Email : boris.leistedt@gmail.com
#		
# UTAR is a R library specifically designed for additive models in MultiCriteria Decision Aid (MCDA). UTAR takes advantage of the XMCDA data standard (http://www.decision-deck.org/xmcda/). All input/output files are under this format. 
# UTAR provides a set of reusable functions for 1) XMCDA data extraction and parsing, 2) the construction of valid preference information 3) the initialization and learning of UTA models, leading to additive value functions.
#
# This software is governed by the CeCILL license (v2) under French law
# and abiding by the rules of distribution of free software. You can
# use, modify and/ or redistribute the software under the terms of the
# CeCILL license as circulated by CEA, CNRS and INRIA at the following
# URL "http://www.cecill.info".
# 
# As a counterpart to the access to the source code and rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty and the software's author, the holder of the
# economic rights, and the successive licensors have only limited
# liability.
#		
# In this respect, the user's attention is drawn to the risks associated
# with loading, using, modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean that it is complicated to manipulate, and that also
# therefore means that it is reserved for developers and experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and, more generally, to use and operate it in the
# same conditions as regards security.
#		
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL license and that you accept its terms.
#
###############################################################################
#


# getValueFunctions return the matrices containing the value functions read in an XML tree. McdaConcept is not yet used
getValueFunctions <- function ( tree,  mcdaConcept = NULL ) 
{	
	tmpErr <- try({
				if( length(tree)>0 ){
					xmcda <- getNodeSet(tree,"//criteria")
				}else{
					return(NULL)
				}
				if( length(xmcda)>0 ){
					criteria <- getNodeSet(xmcda[[1]],"criterion")
				}else{
					return(list("status"="error"))
				}
			})
	if (inherits(tmpErr, "try-error")) {
		return(list("status"="error"))
	}
	err1 <- NULL
	gmatrix <- NULL
	umatrix <- NULL
	if(length(criteria)>0){
		for( p in 1:length(criteria)){
			tmpErr <- try({
						criterion <- getNodeSet(criteria[[p]],"criterionFunction")
					})
			if (inherits(tmpErr, "try-error")) {
				
				return(list("status"="error"))
			}
			
			if(length(criterion)>0){
				for(i in 1:length(criterion)){
					gvec <- c()
					uvec <- c()
					points <- getNodeSet(criterion[[i]],"points")
					point <- getNodeSet(points[[1]],"point")
					if(length(point)>0){
						for (k in 1:length(point)){
							tmpErr <- try({
										g <- getNumericValue(getNodeSet(point[[k]],"abscissa"))[[1]]
										u <- getNumericValue(getNodeSet(point[[k]],"ordinate"))[[1]]
									})
							if (inherits(tmpErr, "try-error")) {
								err1 <- "At least one <point> contains no data."
							}
							gvec <- c(gvec,g)
							uvec <- c(uvec,u)
						}
						tmpErr <- try({
									uvec <- uvec[order(gvec)]
									gvec <- gvec[order(gvec)]
									if (is.null(gmatrix)){
										gmatrix <- matrix(gvec,ncol=length(gvec))
									}else{
										if(length(gvec) > ncol(gmatrix)){
											G <- matrix(NA,nrow=nrow(gmatrix),ncol=length(gvec))
											G[which(!is.nan(gmatrix))] <- gmatrix
											gmatrix <- rbind(G,gvec)
										}else{
											gmatrix <- rbind(gmatrix,c(gvec,rep(NA,ncol(gmatrix)-length(gvec))))
										}
									}
									if (is.null(umatrix)){
										umatrix <- matrix(uvec,ncol=length(uvec))
									}else{
										if(length(uvec) > ncol(umatrix)){
											U <- matrix(NA,nrow=nrow(umatrix),ncol=length(uvec))
											U[which(!is.nan(umatrix))] <- umatrix
											umatrix <- rbind(U,uvec)
										}else{
											umatrix <- rbind(umatrix,c(uvec,rep(NA,ncol(umatrix)-length(uvec))))
										}
									}
								})
						if (inherits(tmpErr, "try-error")) {
							err1 <- "Problem during construction of value functions while extracting"
						}
					}else{
						return(list("status"="error"))
					}
				}
			}else{
				return(list("status"="error"))
			}
		}
	}
	else{
		return(list("status"="error"))
	}
	
	names(gmatrix) <- NULL	
	names(umatrix) <- NULL	
	return(list("gmatrix"=gmatrix,"umatrix"=umatrix,"status"="OK"))
}


# exportLog creates an output file containing a message concerning the execution
exportLog <- function( message , location , error=TRUE , specialName = NULL) 
{
	if(is.null(message)){
		message = "no error"
	}
	
	text = newXMLNode( "text", message )
		if( error == FALSE ){
			logMessage = newXMLNode( "logMessage" )
		}else{
			logMessage = newXMLNode( "errorMessage" )
		}
	methodMessages = newXMLNode( "methodMessages", attrs = c("mcdaConcept"="methodMessages") )
	z = newXMLNode("xmcda:XMCDA", namespace = c(xsi="http://www.w3.org/2001/XMLSchema-instance",xmcda="http://www.decision-deck.org/2009/XMCDA-2.0.0"))
	
	addChildren(logMessage, text)
	addChildren(methodMessages, logMessage)
	addChildren(z, methodMessages)
		
	if(is.null(specialName)){
		finalname = "message.xml"
	}else{
		finalname = specialName
	}
	if( is.null(location) ){
		outputLoc = finalname
	}else{
		outputLoc = paste(location,finalname,sep="/")
	}
	
	status <- saveXML(z, indent=TRUE, file= outputLoc  )
}


# exportSituation creates an output file contoining the solution
exportSituation  <- function( solution , outputsLocation ) 
{
	if( is.null(solution) || solution$validation != TRUE )
	{
		z = newXMLNode("xmcda:XMCDA", namespace = c(xsi="http://www.w3.org/2001/XMLSchema-instance",xmcda="http://www.decision-deck.org/2009/XMCDA-2.0.0"))
		filename <- "valueFunctions.xml"
		whereF =  paste(outputsLocation,filename,sep="/")
		saveXML( z , file=whereF )
		return(NULL)
	}
	listOfOthersACUTA <- c()
	z <- saveUtilityFunctionUnderXML(solution)
	filename <- "valueFunctions.xml"
	whereF =  paste(outputsLocation,filename,sep="/")
	#f <- tempfile()
	#saveXML(z, f, encoding = "UTF-8",indent=TRUE, file=whereF,prefix = '<?xml version="1.0"?>\n')
	saveXML( z , file=whereF )
	z <- NULL
	
}


# performanceTableToXML convert a performanceTable (matrix) to an appropriate XML-XMCDA
performanceTableToXML <- function( data )
{
	z <- xmlTree("xmcda:XMCDA",	
			namespaces=list(xsi="http://www.w3.org/2001/XMLSchema-instance",
					xmcda="http://www.decision-deck.org/2009/XMCDA-2.0.0") ,
			doc = newXMLDoc())
	altNames <- rownames(data)
	critNames <- colnames(data)
	z$addNode("performanceTable",close=FALSE )
	#,attrs=c("mcdaConcept"="performanceTable"))
	for( i in 1:length(altNames))
	{
		z$addNode( "alternativePerformances" , close=FALSE )
		z$addNode( "alternativeID" , altNames[i] )
		for( j in 1:length(critNames))
		{
			
			z$addNode( "performance" , close=FALSE )
			z$addNode( "criterionID" , critNames[j] )
			z$addNode( "value" , close=FALSE )
			z$addNode( "real" , data[i,j] )
			z$closeTag()
			z$closeTag()
		}
		z$closeTag()
	}
	z$closeTag()
	return( z )
}

# computeNormalizedPerformanceTable apply value functions (aggregation procedure) on performanceTable 
computeNormalizedPerformanceTable <- function(data,gmatrix,umatrix)
{
	A <- nrow(data)
	N <- ncol(data)
	datautility = NULL
	for (i in 1:A)
	{
		b <- rep( FALSE, length=N )
		vec <- rep(0, length=N)
		
		for (j in 1:N)
		{
			g <- data[i,j]
			if( g >= min(gmatrix[j,!is.na(gmatrix[j,])]) && g <= max(gmatrix[j,!is.na(gmatrix[j,])]) )
			{
				b[j] <- TRUE
				ginfind <- max(which(gmatrix[j,!is.na(gmatrix[j,])]<=g))
				gsupind <- min(which(gmatrix[j,!is.na(gmatrix[j,])]>=g))
				if (gsupind == ginfind){
					vec[j] <- umatrix[j,ginfind]
				}else{
					x <- c(gmatrix[j,ginfind],gmatrix[j,gsupind])
					y <- c(umatrix[j,ginfind],umatrix[j,gsupind])
					vec[j] <- approx(x,y,xout=g)$y
				}
			}
		}
		if( all(b) == TRUE )
		{
			if( is.null(datautility) )
			{
				datautility <- t(as.matrix(vec))
			}
			else
			{
				datautility <- rbind( datautility , vec )
			}
			rownames(datautility)[nrow(datautility)] <- rownames(data)[i]
		}
	}
	colnames(datautility) <- colnames(data)
	
	return(datautility)
}

# scanInputsFolder automaticly scans a folder and returns a list of
scanInputsFolder <- function( inputsLocation  )
{
	validation <- TRUE
	SOLUTION <- list( "validation" = validation )
	listOfFiles <- list.files( inputsLocation )
	
	listToLookAfter = c( "alternatives.xml" , "alternativesRanking.xml" ,
			"alternativesPreferences.xml" , "alternativesIndifferences.xml" ,
			"criteria.xml" , "delta.xml" , "segments.xml" ,
			"preferencesDirections.xml" , "performanceTable.xml" , 
			"method.xml" )
	for( i in 1:length(listToLookAfter) ){
		name = listToLookAfter[i]
		tmpErr <- try({
					aux = NULL
					if( name == "performanceTable" ){
						aux <- list( "criteriaIDs" = criteriaIDs , "alternativesIDs" = alternativesIDs )
					}
					if( name == "alternativesRanking.xml"
							||
							name == "alternativesPreferences.xml"
							||
							name == "alternativesIndifferences.xml"
							){
						aux <- alternativesIDs
					}
					if( name == "segments.xml" 
							||
							name == "preferencesDirections.xml" 
							){
						aux <- criteriaIDs
					}
					result <- findAndCheck( name , inputsLocation , listOfFiles , aux )
					if( is.null(result$content) && result$validation == TRUE ){
						if( name == "method.xml" ){
							result$content = FALSE
						}
					}					
				})
		if ( inherits(tmpErr, 'try-error') || result$validation == FALSE ) { 
			return( list( "validation" = FALSE , "LOG" = result$LOG ) )
		}else{
			if( !is.null( result$content ) ){
				newname = substr(name,1,nchar(name)-4)
				if(newname == "alternatives"){
					newname <- "alternativesIDs"
				}
				if(newname == "criteria"){
					newname <- "criteriaIDs"
				}
				SOLUTION[[newname]] = result$content[[1]]
				if( name == "alternatives.xml"){
					alternativesIDs <- result$content
				}
				if( name == "criteria.xml"){
					criteriaIDs <- result$content
				}
			}
		}	
	}
	
	return( c( SOLUTION , list("validation"=TRUE) ) )
}

# findAndCheck is analysing each file and creating LOG and content
findAndCheck <- function( filename , inputsLocation , listOfFiles , aux = NULL )
{
	print( paste( "Loading" , filename , sep=" " ) )
	location <- listOfFiles[ listOfFiles == filename ]
	validation <- FALSE
	
	if ( length( location ) == 0 ) 
	{
		print( paste( "Note:" , filename , "is missing" , sep=" " ) )
		LOG <- paste( filename , "is missing" , sep=" " )
		print( paste( "-->" , filename , "checked" , sep=" " ) )
		print( "                            " )
		if( filename == "alternatives.xml" || filename == "criteria.xml" || filename == "performanceTable.xml" || filename == "preferencesDirections.xml"){
			return( list( "validation" = FALSE , "content" = NULL , "LOG" = LOG ) )
		}else{
			return( list( "validation" = TRUE , "content" = NULL , "LOG" = LOG ) )
		}
	}
	else
	{
		location <- paste( inputsLocation , location , sep="/" )
		tmpErr <- try(
				{	xml <- xmlInternalTreeParse( location ) } )
		if (inherits(tmpErr, 'try-error'))
		{ return( list( "validation" = FALSE , "LOG" = "xml parsing error" ) ) }
		
		if( checkXSD( xml ) != 1 )
		{
			LOG <- paste( filename , "is not a valid XMCDA file" , sep=" " )
			print( paste( "Problem :" , filename , "is not a valid XMCDA file" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		result <- extractContent( xml , filename , aux )
		if( result$validation == FALSE ) { 
			return( list( "validation" = FALSE , "LOG" = result$LOG ) )
		}
		validation <- TRUE
		print( "Note: file found and structure ok" )
		print( "                            " )
		return( list( "validation" = validation , "content" = list(result$content) ) )
	} 
}

# extractContent is extracting the content of each XML tree
extractContent <- function( xml , filename , aux = NULL )
{
	validation = FALSE
	LOG <- "Extraction error : invalid filename"
	if( filename == "alternatives.xml" )
	{
		err <- try( {
					alternativesIDs <- getAlternativesIDs ( xml )
				} )
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "alternatives.xml extraction error" ) ) 
		}
		
		if ( is.null( alternativesIDs[[1]] ) || alternativesIDs$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- alternativesIDs[[1]]	
		validation <- TRUE
	}
	
	if( filename == "alternativesRanking.xml" )
	{
		alternativesIDs <- aux[[1]]
		err <- try( {
					alternativesRanking <- getAlternativesValues ( xml , alternativesIDs )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "alternativesRanking.xml extraction error" ) ) 
		}
		if ( is.null(alternativesRanking[[1]]) || alternativesRanking$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem - check alternativesIDs or content" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		alternativesRanking <- alternativesRanking[[1]]
		NalternativesRanking <- matrix(0, nrow=nrow(alternativesRanking),ncol=2)
		for (i in 1:nrow(alternativesRanking) )
		{
			ind <- alternativesRanking[i,1]
			NalternativesRanking[i,1] <- alternativesIDs[ind]
			NalternativesRanking[i,2] <- as.character(alternativesRanking[i,2])
		}
		content <- NalternativesRanking
		validation <- TRUE
	}
	
	if( filename == "alternativesPreferences.xml" )
	{
		alternativesIDs <- aux[[1]]
		err <- try( {
					alternativesPreferences <- getAlternativesComparisonsLabels( xml , alternativesIDs )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "alternativesPreferences.xml extraction error" ) ) 
		}
		if ( alternativesPreferences$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- alternativesPreferences[[1]]
		validation <- TRUE
	}
	
	if( filename == "alternativesIndifferences.xml" )
	{
		alternativesIDs <- aux[[1]]
		err <- try( {
					alternativesIndifferences <- getAlternativesComparisonsLabels( xml , alternativesIDs )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "alternativesIndifferences.xml extraction error" ) ) 
		}
		if ( alternativesIndifferences$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		alternativesIndifferences <- alternativesIndifferences[[1]]
		alternativesIndifferences <- alternativesIndifferences[,c(1,2,3)]
		if( is.vector(alternativesIndifferences) )
		{
			alternativesIndifferences <- t(as.matrix(alternativesIndifferences)) 
		}
		content <- alternativesIndifferences
		validation <- TRUE
	}
	
	if( filename == "criteria.xml" )
	{
		err <- try( {
					criteriaIDs <- getCriteriaIDs ( xml )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "criteria.xml extraction error" ) ) 
		}
		if ( is.null(criteriaIDs[[1]]) || is.null( criteriaIDs$status != "OK" ) )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- criteriaIDs[[1]]
		validation <- TRUE
	}
	
	if( filename == "delta.xml" )
	{
		err <- try( {
					delta <- getParameters ( xml )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "delta.xml extraction error" ) ) 
		}
		if ( is.null(delta[[1]]) || delta$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- delta[[1]]
		validation <- TRUE
	}
	
	if( filename == "method.xml" )
	{
		err <- try( {
					ac <- getParameters ( xml )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "method.xml extraction error" ) ) 
		}
		if ( is.null(ac[[1]]) || ac$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- ac[[1]]
		validation <- TRUE
	}
	
	
	
	if( filename == "performanceTable.xml" )
	{
		criteriaIDs <- aux$criteriaIDs[[1]]
		activeAlternativesIDs <- aux$alternativesIDs[[1]]
		
		err <- try( {
					performanceTable <- getPerformanceTables(xml,altIDs=activeAlternativesIDs,critIDs=criteriaIDs)
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "performanceTable.xml extraction error" ) ) 
		}
		if( is.null(performanceTable[[1]]) || performanceTable$status != "OK")
		{
			
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		content <- performanceTable[[1]]
		validation <- TRUE
	}
	
	if( filename == "segments.xml" )
	{
		criteriaIDs <- aux[[1]]
		err <- try( {
					segments <- getCriteriaValues ( xml , criteriaIDs )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "segments.xml extraction error" ) ) 
		}
		if ( is.null(segments[[1]]) || segments$status != "OK" )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		segments <- segments[[1]]
		content <- rbind( criteriaIDs[segments[,1]] , segments[,2] )
		validation <- TRUE
	}
	
	if( filename == "preferencesDirections.xml" )
	{
		err <- try({
					prefDirections <- getPreferencesDirections ( xml  )
				})
		if ( inherits( err , 'try-error' ) )
		{ 
			return( list( "validation" = FALSE , "LOG" = "preferencesDirections.xml extraction error" ) ) 
		}
		if ( is.null(prefDirections[[1]]) || prefDirections$status != "OK"  )
		{
			LOG <- paste( filename , "XMCDA file problem" , sep=" " )
			print( paste( "Problem :" , filename , "XMCDA file problem" , sep=" " ) )
			return( list( "validation" = validation , "LOG" = LOG ) )  
		}
		prefDirections <- prefDirections[[1]]
		content <- rbind( prefDirections[,1] , prefDirections[,2] )
		validation <- TRUE
	}
	
	return( list( "validation" = validation , "content" = content ) )  
}

# getPreferencesDirections extracts the directions of criteria from the XML tree
getPreferencesDirections <- function(tree)
{
	tmpErr <- try({
				criteriaValues <- getNodeSet(tree,"//criteriaValues")
			})
	if (inherits(tmpErr, "try-error")) {
		
		return(list("status"="error"))
	}
	prefDirections <- NULL
	if(length(criteriaValues)>0){
		tmpErr <- try({
					criterionValue <- getNodeSet(criteriaValues[[1]],"criterionValue")
				})
		if (inherits(tmpErr, "try-error")) {
			
			return(list("status"="error"))
		}
		if(length(criterionValue)>0){
			for(i in 1:length(criterionValue)){
				tmpErr <- try({
							id <- toString(xmlValue(getNodeSet(criterionValue[[i]],"criterionID")[[1]]))
							v <- toString(xmlValue(getNodeSet(getNodeSet(criterionValue[[i]],"value")[[1]],"label")[[1]]))
						})
				if (inherits(tmpErr, "try-error")) {
					
					return(list("status"="error"))
				}
				if(is.null(prefDirections)){
					prefDirections <- as.matrix(c(id,v))
				}else{
					prefDirections <- cbind(prefDirections,c(id,v))	
				}
			}
		}
	}
	return(list(t(prefDirections),"status"="OK"))
}

# combineContents take the information extracted from the inputs and computes the matrices and vectors that will be used 
combineAndRestrictContent <- function( content )
{
	if( content$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=content$LOG ) )
	}
	
	
	if( content$method != "mv" && content$method != "md" && content$method != "ac"){
		content$method <- "none"
	}
	
	content$initialPerformanceTable <- content$performanceTable
	
	content <- restrictAllFilesToCorrectAlternatives( content )
	#content <- checkAlternatives( content )
	if( content$validation == FALSE ) { return( list( "validation"=FALSE , "LOG"=content$LOG ) ) }
	
	content <- restrictAllFilesToCorrectCriteria( content )
	#content <- checkCriteria( content )
	if( content$validation == FALSE ) { return( list( "validation"=FALSE , "LOG"=content$LOG ) ) }
	
	content <- produceOrientedSegment( content )
	if( content$validation == FALSE ) { return( list( "validation"=FALSE , "LOG"=content$LOG ) ) }
	
	if( any( is.na(content$orientedSegment) )){
		return( list( "validation"=FALSE , "LOG"="Error - please check criteria segments and directions" ) )
	}
	content$validation <- TRUE
	
	return( "content" = content  )
}


# restrictToCorrectAlternatives computes corrections on IDs, PT and rankinks taking into account of effective alternatives
restrictAllFilesToCorrectAlternatives <- function( content )
{
	if( content$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=content$LOG ) )
	}
	err <- try({ 
				if( !is.null(content$alternativesIndifferences) ){
					content$alternativesIndifferences <- matrix(t(content$alternativesIndifferences[,c(1,2)]),ncol=2)
				}
			})
	if (inherits(err, "try-error")) {
		return(list("validation"=FALSE,"LOG"="error while restructuring indifferences"))
	}
	
	
	A <- c()
	B <- c()
	definitiveAlternatives <- c()
	
	err <- try({
				if( !is.null(content$alternativesRanking[,1]) && !is.na(content$alternativesRanking[,1]) && length(content$alternativesRanking[,1])>0 ){
					B <- c( B , content$alternativesRanking[,1] )
				}
				if( !is.null(content$alternativesPreferences) && !is.na(content$alternativesPreferences) && length(content$alternativesPreferences[,1])>0 ){
					B <- c( B , content$alternativesPreferences[,1] , content$alternativesPreferences[,2] )
				}
				if( !is.null(content$alternativesIndifferences) && !is.na(content$alternativesIndifferences) && length(content$alternativesIndifferences[,1])>0 ){
					B <- c( B , content$alternativesIndifferences[,1] , content$alternativesIndifferences[,2] )
				}
				if( !is.null(rownames(content$performanceTable)) && !is.na(rownames(content$performanceTable)) && nrow(content$performanceTable)>0 ){
					A <- c( A , rownames(content$performanceTable) )
				}
				if( !is.null(content$alternativesIDs) && !is.na(content$alternativesIDs) && length(content$alternativesIDs)>0 ){
					A <- c( A , content$alternativesIDs )
				}
				
				TOT <- c( A , B )
				for( i in 1:length(TOT) ){
					if( any( A == TOT[i] ) && any( B == TOT[i] ) && !any( definitiveAlternatives==TOT[i] ) ){
						definitiveAlternatives <- c( definitiveAlternatives , TOT[i] )
					}
				}
				content$alternativesIDs <- definitiveAlternatives
			})
	if (inherits(err, "try-error")) {
		return(list("validation"=FALSE,"LOG"="error while restructuring alternativesIDs "))
	}
	
	
	
	
	newPerfTable <- matrix(ncol=ncol(content$performanceTable),nrow=0)
	newAlternativesRanking <- matrix(ncol=2,nrow=0)
	newAltPref <- matrix(nrow=0,ncol=3)
	newAltIndiff <- matrix(nrow=0,ncol=2)
	
	err <- try({
				for( i in 1:length(content$alternativesIDs) ){
					a <- content$alternativesIDs[i]
					if( !is.null(content$alternativesRanking[,1]) && !is.na(content$alternativesRanking[,1]) && length(content$alternativesRanking[,1])>0 ){
						if( any( content$alternativesRanking[,1] == a ) && !any( newAlternativesRanking == a ) ){
							newAlternativesRanking <- rbind( newAlternativesRanking ,content$alternativesRanking[which(content$alternativesRanking[,1]==a),] )
						}
					}
					if( !is.null(content$alternativesPreferences) && !is.na(content$alternativesPreferences) && length(content$alternativesPreferences[,1])>0 ){
						if( any( content$alternativesPreferences[ , 1 ] == a ) ){
							selec <- which(  content$alternativesPreferences[ , 1 ] == a )
							if(length(selec)>0){
								for(j in 1:length(selec) ){
									if( any( content$alternativesIDs == content$alternativesPreferences[ selec[j] , 2 ]) ){
										if( !any( newAltPref[,1] == content$alternativesPreferences[ selec[j] , 1 ] )
												&&
												!any( newAltPref[which(newAltPref[,1] == content$alternativesPreferences[ selec[j] , 1 ]),2] == content$alternativesPreferences[ selec[j] , 2 ] )
												
												){
											newAltPref <- rbind( newAltPref , content$alternativesPreferences[ selec[j] ,] )
										}
									}
								}
							}
						}
					}
					if( !is.null(content$alternativesIndifferences) && !is.na(content$alternativesIndifferences) && length(content$alternativesIndifferences[,1])>0 ){
						if( any( content$alternativesIndifferences[ , 1 ] == a ) ){
							selec <- which(  content$alternativesIndifferences[ , 1 ] == a )
							if(length(selec)>0){
								for(j in 1:length(selec) ){
									if( any( content$alternativesIDs == content$alternativesIndifferences[ selec[j] , 2 ]) ){
										if( !any( newAltIndiff[,1] == content$alternativesIndifferences[ selec[j] , 1 ] )
												&&
												!any( newAltIndiff[which(newAltIndiff[,1] == content$alternativesIndifferences[ selec[j] , 1 ]),2] == content$alternativesIndifferences[ selec[j] , 2 ] )
												
												){
											newAltIndiff <- rbind( newAltIndiff , content$alternativesIndifferences[ selec[j] ,] )
										}
									}
								}
							}
						}
					}
					if( !is.null(rownames(content$performanceTable)) && !is.na(rownames(content$performanceTable)) && nrow(content$performanceTable)>0 ){
						if( any( rownames(content$performanceTable) == a ) && !any( rownames( newPerfTable ) == a ) ){
							newPerfTable <- rbind( newPerfTable , content$performanceTable[which(rownames(content$performanceTable)==a),])
							rownames( newPerfTable )[nrow(newPerfTable)] = a	
						}else{
							return(list("validation"=FALSE,"LOG"="Some alternatives you asked are not in performanceTable"))
						}
					}
				}
				content$alternativesRanking <- newAlternativesRanking
				content$performanceTable <- newPerfTable
				content$alternativesPreferences <- newAltPref
				content$alternativesIndifferences <- newAltIndiff
			})
	if (inherits(err, "try-error")) {
		return(list("validation"=FALSE,"LOG"="error while restructuring data"))
	}
	
	
	
	return( content  )
}

# restrictToCorrectCriteria
restrictAllFilesToCorrectCriteria <- function( content )
{
	if( content$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=content$LOG ) )
	}
	
	if( !is.null(content$segments) ){
		newSegments <- matrix(t(content$segments[2,]),nrow=1)
		colnames(newSegments) <- content$segments[1,]
		content$segments <- newSegments
		rm( newSegments )
	}
	
	newPrefDir <- matrix(t(content$preferencesDirections[2,]),nrow=1)
	colnames(newPrefDir) <- content$preferencesDirections[1,]
	content$preferencesDirections <- newPrefDir
	rm( newPrefDir )
	
	newCriteriaIDs <- c()
	newSegments <- matrix(nrow=1,ncol=0)
	newPrefDir <- matrix(nrow=1,ncol=0)
	newPerfTable <- matrix(ncol=0,nrow=nrow(content$performanceTable))
	
	
	if( !is.null(content$segments) && length(content$segments)>0 ){
		for( i in 1:ncol(content$segments) ){
			a <- colnames(content$segments)[i]
			if(
					( is.null(content$criteriaIDs) || any(content$criteriaIDs==a) )
					&&
					( is.null(content$preferencesDirections) || any(colnames(content$preferencesDirections)==a) )
					&&
					( is.null(content$performanceTable) || any(colnames(content$performanceTable)==a) )
					&&
					( !any(colnames(newSegments) == a) )
					){
				newSegments <- cbind( newSegments , content$segments[,which(colnames(content$segments)==a)[1]] )
				colnames(newSegments)[ncol(newSegments)] <- a
				rownames(newSegments) <- NULL
			}
		}
		content$segments <- newSegments
		rm(newSegments)
	}
	if( !is.null(content$preferencesDirections) && length(content$preferencesDirections)>0 ){
		for( i in 1:ncol(content$preferencesDirections) ){
			a <- colnames(content$preferencesDirections)[i]
			if(
					( is.null(content$criteriaIDs) || any(content$criteriaIDs==a) )
					&&
					( is.null(content$performanceTable) || any(colnames(content$performanceTable)==a) )
					&&
					( is.null(content$segments) || any(colnames(content$segments)==a) )
					&&
					( !any(colnames(newPrefDir) == a) )
					){
				newPrefDir <- cbind( newPrefDir , content$preferencesDirections[,which(colnames(content$preferencesDirections)==a)[1]] )
				colnames(newPrefDir)[ncol(newPrefDir)] <- a
				rownames(newPrefDir) <- NULL
			}
		}
		content$preferencesDirections <- newPrefDir
		rm(newPrefDir)
	}
	if( !is.null(content$performanceTable) && ncol(content$performanceTable)>0 ){
		for( i in 1:ncol(content$performanceTable) ){
			a <- colnames(content$performanceTable)[i]
			if(
					( is.null(content$criteriaIDs) || any(content$criteriaIDs==a) )
					&&
					( is.null(content$preferencesDirections) || any(colnames(content$preferencesDirections)==a) )
					&&
					( is.null(content$segments) || any(colnames(content$segments)==a) )
					){
				newPerfTable <- cbind( newPerfTable , content$performanceTable[,which(colnames(content$performanceTable)==a)[1]])
				colnames( newPerfTable )[ncol(newPerfTable)] = a
			}
		}
		content$performanceTable <- newPerfTable
		rm(newPerfTable)
	}
	if( !is.null(content$criteriaIDs) && length(content$criteriaIDs)>0 ){
		for( i in 1:length(content$criteriaIDs) ){
			a <- content$criteriaIDs[i]
			if(
					( is.null(content$preferencesDirections) || any(colnames(content$preferencesDirections)==a) )
					&&
					( is.null(content$performanceTable) || any(colnames(content$preferencesDirections)==a) )
					&&
					( is.null(content$segments) || any(colnames(content$segments)==a) )
					){
				newCriteriaIDs <- c( newCriteriaIDs , a )
			}
		}
		content$criteriaIDs <- newCriteriaIDs
		rm(newCriteriaIDs)
	}
	
	
	return( c(content, list("validation"=TRUE))  )
}



# produceOrientedSegment combines the information about criteria, directions and segments
produceOrientedSegment <- function( content )
{
	if( content$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=content$LOG ) )
	}
	err <- try({
				if( is.null( content$segments ) ) #||  is.null( content$preferencesDirections ) )
				{
					content$orientedSegment <- rep(1,length=length(content$criteriaIDs))
					names( content$orientedSegment ) <- content$criteriaIDs 
					orientedSegment <- c()
					crit <- c()
					for( i in 1:length(content$criteriaIDs) )
					{
						if(	any( colnames(content$preferencesDirections) == content$criteriaIDs[ i ] )	)
						{
							crit <- c( crit , content$criteriaIDs[ i ] )
							dir <- content$preferencesDirections[1, which(colnames(content$preferencesDirections) == content$criteriaIDs[ i ] ) ]
							if( dir == "min" )
							{
								g <- -1
							}
							if( dir == "max" )
							{
								g <- 1
							}
							orientedSegment <- c( orientedSegment , g )
							names( orientedSegment ) <- crit 
							content$orientedSegment <- orientedSegment
						}
					}
					return( content )
				}
			})
	if (inherits(err, "try-error")){
		return( list( "validation"=FALSE , "LOG"="fatal error while producing oriented segment 1" ) )
	}
	
	crit <- c()
	orientedSegment <- c()
	
	if( !is.null(content$segments) ){
		err <- try({
					for( i in 1:length(content$criteriaIDs) )
					{
						if(
								any( colnames(content$segments) == content$criteriaIDs[ i ] )
								&&
								any( colnames(content$preferencesDirections) == content$criteriaIDs[ i ] )
								)
						{
							crit <- c( crit , content$criteriaIDs[ i ] )
							g <- content$segments[1,which(colnames(content$segments) == content$criteriaIDs[ i ] ) ]
							dir <- content$preferencesDirections[1, which(colnames(content$preferencesDirections) == content$criteriaIDs[ i ] ) ]
							if( dir == "min" )
							{
								g <- - as.numeric(g)
							}
							if( dir != "max" && dir != "min" )
							{
								g <- NA
							}
							
						}
						else
						{
							g <- NA
						}
						if( max( content$performanceTable[, i] ) == min( content$performanceTable[, i] )  )
						{
							g <- 0
						}
						orientedSegment <- c( orientedSegment , g )
						names( orientedSegment ) <- crit 
					}
				})
	}
	if (inherits(err, "try-error")){
		return( list( "validation"=FALSE , "LOG"="fatal error while producing oriented segment 2" ) )
	}
	
	return( c( content , list( "orientedSegment" = orientedSegment) ) )
}

computeUTASTAR <- function( content )
{
	if( content$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=content$LOG ) )
	}
	
	if( is.null(content$segments) ){
		segmentation = FALSE
	}else{
		segmentation = TRUE
	}
	
	err <- try({
				result <- 
						computeUTASTARmatrices( 
								content$performanceTable , 
								content$alternativesRanking , 
								content$delta ,
								content$alternativesPreferences ,
								content$alternativesIndifferences ,
								content$orientedSegment ,
								segmentation 
						)
			})
	if (inherits(err, "try-error") || result$validation == FALSE ){
		return( list( "validation"=FALSE , "LOG"="error while computing constraint matrices for UTASTAR method" ) )
	}
		
	err <- try({
				xvec <- 
						solveUTASTAR(
								result$c ,
								result$A ,
								result$Aeq ,
								result$b ,
								result$beq ,
								length(content$orientedSegment)
						)
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error while solving LP-UTASTAR method" ) )
	}
	if( xvec$validation == FALSE ){
		return( list( "validation"=FALSE , "LOG"=xvec$LOG ) )
	}
	
	umatrix <- buildUmatrix(xvec$x,result$segs)
	#rownames(umatrix) = rownames(result$gmatrix)
	
	return( c(xvec, list("A"=result$A , "b"=result$b , "Aeq"=result$Aeq , "beq"=result$beq , "gmatrix"=result$gmatrix, "umatrix" = umatrix , "segs"=result$segs , "method"=content$method ) ) )
}


# computeUTASTARmatrices computes the constraints and lp problem for the UTASTAR disaggregation model
computeUTASTARmatrices <- function( performanceTable , ranking , delta , prefPairs , indiffPairs , prefDirections , segmentation = FALSE  )
{
	err <- try({
				if(nrow(ranking) == 0){
					ranking <- NULL
				}
				if( is.null(delta) ){
					delta <- 0.00001
				}
				# toutes les paires de preferences
				if( !is.null(prefPairs) ){
					totalPrefPairs = prefPairs
				}else{
					totalPrefPairs = matrix(ncol=3,nrow=0)
				}
				# toutes les paires d'indifferences
				if( !is.null(indiffPairs) ){
					totalIndiffPairs = indiffPairs
				}else{
					totalIndiffPairs =  matrix(ncol=2,nrow=0)
				}
				
				# on transforme le ranking en paires
				if( !is.null(ranking) ){
					ranking <- ranking[order(as.numeric(ranking[,2])),]
					M = nrow(ranking)
					for( i in 1:(M-1) ){
						alt1 <- ranking[i,1]
						r1 <- ranking[i,2]
						for( j in (i+1):(i+1)){ #:M ){  # ????? TODO 
							alt2 <- ranking[j,1]
							r2 <- ranking[j,2]
							if( r1 == r2 ){
								totalIndiffPairs <- rbind( totalIndiffPairs , c(alt1,alt2) )
							}else{
								totalPrefPairs <- rbind( totalPrefPairs , c(alt1 , alt2 , NA))
							}
						}
					}
				}
				if( nrow(totalPrefPairs)==0 ){
					totalPrefPairs = NULL
				}
				if( nrow(totalIndiffPairs)==0 ){
					totalIndiffPairs = NULL
				}
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error in preliminary computations of UTASTAR constraints" ) )
	}
	
	print("---totalPrefPairs---")
	print(totalPrefPairs)
	print("---totalIndiffPairs---")
	print(totalIndiffPairs)
	
	# début de la construction
	err <- try({
				# nbre de critères
				Ncrit = length( prefDirections )
				
				# nbre de paires
				if( !is.null(totalPrefPairs) ){
					Npp = nrow( totalPrefPairs )
				}else{
					Npp <- 0
				}
				if( !is.null(totalIndiffPairs) ){
					Nip = nrow( totalIndiffPairs )
				}else{
					Nip <- 0
				}
				# nbre d'alternatives
				Nalt <- countNbDiffAlternatives( totalPrefPairs , totalIndiffPairs )
				
				# segmentation des fonctions d'utilité
				R <- constructGmatrix( prefDirections , performanceTable , segmentation )
#########################			prefDirections <- R$prefDirections
				gmatrix <- R$gmatrix 
				S <- sum( abs( as.numeric(prefDirections) ) )
				
				
				V <- 2*Nalt + S + Ncrit
				
				A <- matrix(0,nrow=Npp+S,ncol=V)
				b <- matrix(0,nrow=Npp+S,ncol=1)
				
				Aeq = matrix(0,nrow=Nip+Ncrit+1,ncol=V)
				beq = matrix(0,nrow=Nip+Ncrit+1,ncol=1)
				
				
				if( !is.null(totalPrefPairs) ){
					for ( i in 1:Npp )
					{
						aindex <- which(rownames(performanceTable) == totalPrefPairs[i,1])
						bindex <- which(rownames(performanceTable) == totalPrefPairs[i,2])
						
						for( j in 1:Ncrit ){		
							crit <- names(prefDirections)[j]
							
							
							jPT <- which( colnames(performanceTable) == crit )
							g <- gmatrix[ which( rownames(gmatrix) == crit ) , ]
							
							
							ga <- performanceTable[aindex,jPT]
							gb <- performanceTable[bindex,jPT]
							
							gainfind <- max(which(g<=ga))
							gasupind <- min(which(g>=ga))
							gbinfind <- max(which(g<=gb))
							gbsupind <- min(which(g>=gb))
							
							gainf <- g[gainfind]
							gasup <- g[gasupind]
							gbinf <- g[gbinfind]
							gbsup <- g[gbsupind]
							
							
							if (j == 1){ x <- 0 }else{
								x <- sum(abs(as.numeric(prefDirections[1:(j-1)]))) +j-1
							}
							
							if (gainf == gasup) {
								A[i,x+gainfind] <- A[i,x+gainfind]+1
							}else{
								A[i,x+gainfind] <- A[i,x+gainfind]+ (gasup-ga)/(gasup-gainf)
								A[i,x+gasupind] <- A[i,x+gasupind]+ (ga-gainf)/(gasup-gainf)
							}
							
							if (gbinf == gbsup) {
								A[i,x+gbinfind] <- A[i,x+gbinfind]-1
							}else{
								A[i,x+gbinfind] <- A[i,x+gbinfind] - (gbsup-gb)/(gbsup-gbinf)
								A[i,x+gbsupind] <- A[i,x+gbsupind] - (gb-gbinf)/(gbsup-gbinf)
							}
					  	}
					
					
					
						x <- aindex-1+S+Ncrit
						A[i,x] <- -1
						A[i,x+Nalt] <- 1
					
						x <- aindex+S+Ncrit
						A[i,x] <- 1
						A[i,x+Nalt] <- -1
					
						if( is.na(totalPrefPairs[i,3]) )
						{
							b[i] = as.numeric( delta )
						}
						else
						{
							b[i] = as.numeric( totalPrefPairs[i,3] )
						}
					
					}
					
					for ( i in 1:Ncrit ){
						if (i==1){
							x <- 0
							y <- Npp
						}else{
							x <- sum(abs(as.numeric(prefDirections[1:(i-1)])))+i-1
							y <- sum(abs(as.numeric(prefDirections[1:(i-1)])))+Npp
						}
						
						s <- sign(as.numeric(prefDirections[i]))
						if( s != 0 ){
							for (j in (1:abs(as.numeric(prefDirections[i])))){
								A[y+j,x+j] <- -s
								A[y+j,x+j+1] <- s
							}
						}
					}
					
				}
				
				
				if( !is.null(totalIndiffPairs) ){
					
					for ( i in (1:Nip) )
					{
						aindex <- which(rownames(performanceTable) == totalIndiffPairs[i,1])
						bindex <- which(rownames(performanceTable) == totalIndiffPairs[i,2])
						
						y <- i
						
						for ( j in (1:Ncrit) )
						{
							
							crit <- names(prefDirections)[j]
							jPT <- which( colnames(performanceTable) == crit )
							g <- gmatrix[ which( rownames(gmatrix) == crit ) , ]
							
							ga <- performanceTable[aindex,jPT]
							gb <- performanceTable[bindex,jPT]
							
							gainfind <- max(which(g<=ga))
							gasupind <- min(which(g>=ga))
							gbinfind <- max(which(g<=gb))
							gbsupind <- min(which(g>=gb))
							
							gainf <- g[gainfind]
							gasup <- g[gasupind]
							gbinf <- g[gbinfind]
							gbsup <- g[gbsupind]
							
							
							
							if (j==1){
								x <- 0
							}else{
								x <- sum(abs(as.numeric(prefDirections[1:(j-1)])))+j-1
							}
							if (gainf == gasup) {
								Aeq[y,x+gainfind] <- Aeq[y,x+gainfind]+1
							} else {
								Aeq[y,x+gainfind] <- Aeq[y,x+gainfind]+ (gasup-ga)/(gasup-gainf)
								Aeq[y,x+gasupind] <- Aeq[y,x+gasupind]+ (ga-gainf)/(gasup-gainf)
							}
							
							if (gbinf == gbsup) {
								Aeq[y,x+gbinfind] <- Aeq[y,x+gbinfind]-1
							} else {
								Aeq[y,x+gbinfind] <- Aeq[y,x+gbinfind] - (gbsup-gb)/(gbsup-gbinf)
								Aeq[y,x+gbsupind] <- Aeq[y,x+gbsupind] - (gb-gbinf)/(gbsup-gbinf)
							}	
						}
						
						
						if (i==1){
							x <- S+Ncrit+aindex-1
						}else{
							x <- S+Ncrit+aindex-1
						}
						
						Aeq[y,x] <- -1
						Aeq[y,x+Nalt] <- 1
						
						x <- S+Ncrit+bindex-1
						Aeq[y,x] <- 1
						Aeq[y,x+Nalt] <- -1
					}	
					
				}
				
				for (i in 1:Ncrit){
					y=Nip+i
					if(i==1)
					{
						infe <- 1
					}
					else
					{
						infe <- sum(abs(as.numeric(prefDirections[1:(i-1)])))+i
					}
					supe <- sum(abs(as.numeric(prefDirections[1:i])))+i
					if (sign(as.numeric(prefDirections[i]))>0)
					{
						Aeq[y,infe]=1
						Aeq[Nip+Ncrit+1,supe]=1
					}
					else
					{
						Aeq[y,supe]=1
						Aeq[Nip+Ncrit+1,infe]=1
					}
				}
				beq[Nip+Ncrit+1]=1
				
				
				b <- as.vector(b)
				beq <- as.vector(beq)
				
				c <- matrix(1,nrow=1,ncol=V)
				c[1,1:(Ncrit+S)]=0
				c <- as.vector(c)
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error during computation of UTASTAR raw constraints" ) )
	}
	
	return( list( "A"=A , "b"=b , "Aeq"=Aeq , "beq"=beq , "c"=c , "segs"=prefDirections , "gmatrix"=gmatrix , "validation"=TRUE ) )
}


# countNbDiffAlternatives
countNbDiffAlternatives <- function( alternativesPreferences , alternativesIndifferences )
{
	err <- try({
				nams <- c()
				if( !is.null(alternativesPreferences) ){
					nams <- c( nams , alternativesPreferences[,1] , alternativesPreferences[,2] )
				}
				if( !is.null(alternativesIndifferences) ){
					nams <- c( nams , alternativesIndifferences[,1] , alternativesIndifferences[,2] )
				}
				
				nb <- nams[1]
				for ( i in 2:length(nams) )
				{
					if( all( nb != nams[i] ) )
					{
						nb <- c( nb , nams[i] )
					}
				}
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error counting alternatives" ) )
	}
	
	return( length(nb) )
}



# constructGmatrix
constructGmatrix <- function( prefDirections , performanceTable , segmentation ){
	
	err <- try({
				Glist <- list()
				if( segmentation == TRUE ){
					for( i in 1:ncol(performanceTable) ){
						PT <- performanceTable[,i]
						seg <- prefDirections[which(names(prefDirections)==colnames(performanceTable)[i])] 
						gmin <- min(PT)
						gmax <- max(PT)
						g <- seq(from=gmin,by=((gmax-gmin)/abs(as.numeric(seg))), to=gmax)
						prefDirections[which(names(prefDirections)==colnames(performanceTable)[i])] <- sign(as.numeric(seg))*length(g)
						Glist[[ colnames(performanceTable)[i] ]] <- g
				 }
				}else{
					for( i in 1:ncol(performanceTable) ){
						g <- c()
						PT <- performanceTable[,i]
						seg <- prefDirections[which(names(prefDirections)==colnames(performanceTable)[i])] 
						for( j in 1:length(PT) ){
							if( !any( g == PT[j] ) ){
								g <- c(g,PT[j])
							}
						}
						g <- g[order(g)]
						prefDirections[which(names(prefDirections)==colnames(performanceTable)[i])] <- sign(as.numeric(seg))*length(g)
						Glist[[ colnames(performanceTable)[i] ]] <- g
					}
				}
				
				L <- 0
				for( i in 1:length(Glist) ){
					if( length( Glist[[i]] ) > L ){
						L <- length(Glist[[i]])
					}
				}
				gmatrix = matrix(ncol=L,nrow=0)
				for( i in 1:length(Glist) ){
					if( length( Glist[[i]] ) < L ){
						gmatrix <- rbind(gmatrix,c( Glist[[i]] , rep(NA,L-length(Glist[[i]]))))
					}else{
						gmatrix <- rbind(gmatrix,Glist[[i]])
					}
					rownames(gmatrix)[nrow(gmatrix)] <- names(Glist)[i]
				}
				colnames(gmatrix)=NULL
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error during construction of Gmatrix" ) )
	}
	return( list( "prefDirections"=prefDirections , "gmatrix"=gmatrix ))
}

# solveUTASTARlp solves the lp problem for the UTASTAR disaggregation model
solveUTASTAR <- function( c , A , Aeq , b , beq , nC )
{
	# Linear Programming
	# err <- try({
	#			uy=c(rep(">=",length(b)),rep("==",length(beq)))
	#			b[which(b>0)] <- b[which(b>0)] + rep(10^(-4),length(b[which(b>0)]))
	#			SOL <- lp(direction = "min",objective.in=c,const.mat=rbind(A,Aeq),const.dir=uy,const.rhs=c(b,beq),presolve=1)
	#			x <- SOL$solution
	#		})
	
	
	# Quadratic Programming
	library(LowRankQP)
	nAeq <- cbind(Aeq,matrix(0,ncol=length(b),nrow=nrow(Aeq)))
	nV <- diag(rep(-1,nrow(A)))
	nA <- cbind(A,nV)
	Amat <- rbind(nAeq,nA)
	if( nrow(Aeq)-nC > 1 ){
		lll = rep(1, nrow(Aeq)-nC-1 )
		Amat = cbind(Amat,rep(0,nrow(Amat)))
		Amat[1:length(lll),ncol(Amat)] = lll
		dvec <- as.vector(c(c,1,rep(0,length(b))))
	}else{
		dvec <- as.vector(c(c,rep(0,length(b))))
		}
	Vmat <- matrix(0,nrow=ncol(Amat),ncol=ncol(Amat))
	bvec <- c(beq,b)
	uvec <- rep(1,ncol(Amat))
	err <- try({
				SOL <- LowRankQP(Vmat,dvec,Amat,bvec,uvec,method="LU",verbose=FALSE)
			})
	if (inherits(err, 'try-error'))
	{ return( list( "validation" = FALSE , "LOG" = "METHOD ERROR : FAILED TO CONVERGE" ) ) }
	
	x <- SOL[["alpha"]]
	
	if( all( is.na(x) ) )
	{ return( list( "validation" = FALSE , "LOG" = "Error - failed to converge, due to bad information. Please check your data, rescale the problem, or try with less constraints." ) ) }
	
	x <- as.vector(x)
	x <- x[1:ncol(A)]
	
	return(list("x"=x,"validation"=TRUE))	
}


# computePostOptimalityAnalysis
computePostOptimalityAnalysis <- function( sol ){
	LOG = sol$LOG
	if( sol$validation == FALSE )
	{
		return( list( "validation"=FALSE , "LOG"=sol$LOG ) )
	}
	
	err <- try({
				LOG = NULL
				xAC = NULL
				x <- sol$x
				A <- sol$A
				b <- sol$b
				Aeq <- sol$Aeq
				beq <- sol$beq
				segs <- sol$segs
				method <- sol$method
				N <- length( as.numeric(segs) )
				S <- sum(abs(as.numeric(segs)))
				sigmaoutput<-0
				status <- FALSE
			})
	if (inherits(err, 'try-error')){ 
		return( list( "validation" = FALSE , "LOG" = "Analytic Center Error during preliminary computations" ) ) 
	}
	
	if ((max(x[(S+N+1):length(x)]) > 0.00001 )){  
		# Contraintes non satisfaites
		LOG <- "One or more constraints are not satisfied ; UTA partial success"
		xAC <- x
	}else{
		# Contraintes satisfaites
		
		if( method == "ac" ){
			# Analytic Center
			err <- try({
						A <- -A
						b <- -b
						outAC <- analyticCenter( x[1:(S+N)] , A[,1:(S+N)] , b , Aeq[,1:(S+N)] )
					})
			if (inherits(err, 'try-error')){ 
				return( list( "validation" = FALSE , "LOG" = "Analytic Center Error" ) ) 
			}
			if( outAC$validation == TRUE ){
				xAC <- round(outAC$x,digits = 6)
				LOG = "Analytic Center method successfuly computed"
			}else{
				return( list("validation"=FALSE , "LOG"=outAC$LOG ) )
			}
		}
		
		if( method == "md" ){
			err <- try({
						outAC <- utamp( A[,1:(S+N)] , b , Aeq[,1:(S+N)] , beq , as.integer(segs) )
					})
			if (inherits(err, 'try-error')){ 
				return( list( "validation" = FALSE , "LOG" = "UTAMP - Max delta Error" ) ) 
			}
			if( outAC$validation == TRUE ){
				xAC <- round(outAC$x,digits = 6)
				LOG = "UTAMP - Max delta method successfuly computed"
			}else{
				return( list("validation"=FALSE , "LOG"=outAC$LOG ) )
			}
			
		}
		
		if( method == "mv" ){
			err <- try({
						outAC <- meanValue( A[,1:(S+N)] , b , Aeq[,1:(S+N)] , beq , as.integer(segs) )
						#outAC <- meanValue( A , b , Aeq , beq , as.integer(segs) )
					})
			if (inherits(err, 'try-error')){ 
				return( list( "validation" = FALSE , "LOG" = "Mean Value method error" ) ) 
			}
			if( outAC$validation == TRUE ){
				xAC <- round(outAC$x,digits = 6)
				LOG = "Mean Value method successfuly computed"
			}else{
				return( list("validation"=FALSE , "LOG"=outAC$LOG ) )
			}
			
		}
		
		if( method == "none" ){
			# Pas de méthode postOpt
			xAC <- x
			LOG = "Computation : Classical UTASTAR without Analytic Center"
		}
	}
	
	if ( is.null(xAC) || inherits(err, 'try-error')){ 
		return( list( "validation" = FALSE , "LOG" = "Computation error during post optimality analysis" ) ) 
	}
	
	umatrix <- buildUmatrix( xAC , segs )
	return( list( "validation"=TRUE , "LOG"=LOG , "x" = xAC , "umatrix"=umatrix , "gmatrix"=sol$gmatrix ) )
}


# Mean Value post-optimality method for UTA
meanValue <- function(A,b,Aeq,beq,segs){
	library( lpSolve )
	library( linprog )
	
	err <- try({
				
				nCrit = length(segs)
				S = sum(abs(segs)) + nCrit
				nsig = ncol(A) - S
				xMV = rep( 0 , ncol(A) )
				
				print("c's")
				
				for( i in 1:nCrit ){
					c = rep( 0 , ncol(A) )
					
					if(i==1){
						infe <- 1
					}else{
						infe <- sum(abs(segs[1:(i-1)]))+i
					}
					supe <- sum(abs(segs[1:i]))+i
					if( segs[i] != 0 ){
						if (sign(segs[i])>0){
							c[supe] = 1
						}else{
							c[infe] = 1
						}
					}
					
					#print(c)
					c_min = c
					c_max = -c
										
					err <- try({
								
								lp_min = lp( direction = "min" , 
											objective.in = c , 
											const.mat = rbind( A , Aeq ) ,
											const.dir = c( rep(">",nrow(A)) , rep("==",nrow(Aeq)) ) ,
											const.rhs = c( b , beq )  )
								lp_max =	lp( direction = "max" , 
											objective.in = c , 
											const.mat = rbind( A , Aeq ) ,
											const.dir = c( rep(">",nrow(A)) , rep("==",nrow(Aeq)) ) ,
											const.rhs = c( b , beq )  )
								
								#lp_min = solveUTASTAR(c_min,A,Aeq,b,beq)
								#lp_max = solveUTASTAR(c_max,A,Aeq,b,beq)
								
								#print(lp_min)
								#print(lp_max)
											
								#if( lp_min$validation == TRUE && lp_max$validation == TRUE ){
								#	x_min = lp_min$x
								#   x_max = lp_max$x
			
								if( lp_min$status == 0 && lp_max$status == 0 ){
									x_min = lp_min$solution
								    x_max = lp_max$solution
								}else{
									print("No feasible solution found")
									return( list( "validation" = FALSE , "LOG" = "Mean Value - error or no feasible solution. Try to rescale or to use another post-opt method" ) ) 
								}
								
							})
					if (inherits(err, 'try-error')){ 
						return( list( "validation" = FALSE , "LOG" = "Mean Value internal computation error" ) ) 
					}
					xMV = xMV + ( x_min + x_max ) / ( 2 * nCrit)
					
				}
	})
	if (inherits(err, 'try-error')){ 
		return( list( "validation" = FALSE , "LOG" = "Mean Value computation error" ) ) 
	}
	
	print( "--------------------------" )
	print( " X MEAN VALUE ")
	print( xMV )
	print( "--------------------------" )
	
	return( list("x"=xMV , "validation"=TRUE) )
}


# Delta maximization (utamp) post-optimality method for UTA
utamp <- function(A,b,Aeq,beq,segs){
	
	library( lpSolve )
	library( linprog )
	
	
	err <- try({
				nCrit = length(segs)
				S = sum(abs(segs))
				Npp = nrow(A) - S
				c = c( rep(0,ncol(A)) , 1 ) 
				D = c( rep(-1,Npp) , rep(0,S) )
				A = cbind( A , as.matrix(D) )
				b = rep( 0 , length(b) )
				Aeq = cbind( Aeq , rep(0,nrow(Aeq)) )
				
				sol = lp( direction = "max" , 
						objective.in = c , 
						const.mat = rbind( A , Aeq ) ,
						const.dir = c( rep(">",nrow(A)) , rep("==",nrow(Aeq)) ) ,
						const.rhs = c( b , beq )  )
				
				if( sol$status == 0 ){
					x = sol$solution
				}else{
					print("No feasible solution found")
					return( list( "validation" = FALSE , "LOG" = "Mean Value - error or no feasible solution" ) ) 
				}
				
	})
	if (inherits(err, 'try-error')){ 
		return( list( "validation" = FALSE , "LOG" = "Utamp (max delta) computation error" ) ) 
	}
	
	return( list("x"=x , "validation"=TRUE) )
}


# Analytic Center post-optimality method for UTA
analyticCenter <- function(x,A,b,Aeq)
{
	if(!is.vector(x)){
		return (list("LOG"="x should be a vector","validation"=FALSE))
		}
	if(!is.matrix(A)){
		return (list("LOG"="A should be a matrix","validation"=FALSE))
		}
	if(!is.vector(b)){
		return (list("LOG"="b should be a vector","validation"=FALSE))
		}
	if(!is.matrix(Aeq)){
		return (list("LOG"="Aeq should be a matrix","validation"=FALSE))
		}
		
	err <- try({
	fac <- 0.95
	it <- 0
	oldnorm <- 0
	stepredcount <- 0
	flag <- 1
	
	library(MASS)
	if (is.null(x))
		x = matrix(1,nrow=ncol(A),ncol=1) 
	if (is.null(Aeq)){
		Z= diag(rep(1,ncol(A)))
	}else{
		Z <- nullspace(Aeq)
	}
	})
	if (inherits(err, 'try-error')){
		return (list("LOG"="Problem while computing nullspace","validation"=FALSE))
		}
	
	err <- try({
		out <- analyticCenterInitialization(x,A,b)
	})
	if (inherits(err, 'try-error')){
		return (list("LOG"="Problem while initializing analytic center","validation"=FALSE))
		}
		
	x <- out[[1]]
	flag <- out[[2]]
	oldnorm <- 0
	xini <- x
	
	if (flag>0){
		while (1){
			s <- b - A %*% x
			sbis = as.vector(s)
			
			e = matrix(1,nrow=nrow(s),ncol=1)
			iS <- diag(sbis^(-1))
			
			grad <- matrix(nrow=ncol(A),ncol=1)
			grad <- t(A) %*% iS %*% e
			Hess <- t(A) %*% iS %*% iS %*% A
			
			Zgrad <- t(Z) %*% grad
			gradnorm <- sqrt(sum(Zgrad^2))
			
			if (gradnorm < 1e-6)
				break
			if (abs(oldnorm-gradnorm)<1e-6)
				break
			oldnorm = gradnorm
			dz <- - pseudoinverse(t(Z) %*% Hess %*% Z) %*% Zgrad
			n <- Z %*% dz

			while (any((A %*% (x+n)) >= b)){
				n = n %*% fac
				stepredcount = stepredcount + 1
				if(stepredcount >200){
					print("step redcount error")
					break
				}
			}
			x <- x + n
			it = it + 1
			if (it>200) {
				flag=0
				break
			}
		}
	}
	return (list("x"=x,"validation"=TRUE, LOG="OK"))	
}


# Analytic center initialization procedure
analyticCenterInitialization <- function(x,A,b)
{
	flag <- 1
	stepred <- 0.9
	it1 <- 0
	while (any(A %*% x >= b)){
		prode <- A %*% x
		indexoutside <- which(A %*% x >= b)
		indexinside <- which(A %*% x < b)
		val <- min(prode[indexoutside])[1]
		subindex <- which.min(prode[indexoutside]) 
		index <- indexoutside[subindex]
		dir <- -A[index,]
		it2 <-0
		while (any(A[indexinside,] %*% (x+dir) >= b[indexinside])){
			dir <- dir * stepred
			it2 <- it2+1
			if (it2 > 300){
				print("it2 block")
				it2B <- 1
				break
			}
		}
		it1 <- it1 + 1
		if ((it1 > 300) || (it2 > 300)){
			flag <- 0
			print("ERROR ACINI")
			break
		}
		x <- x + dir
	}
	return(list(x,flag))
}


# Pseudoinverse computation
pseudoinverse <- function (m, tol)
{
	msvd = fast.svd(m, tol)
	if (length(msvd$d) == 0) {
		return(array(0, dim(m)[2:1]))
	}
	else {
		return(msvd$v %*% (1/msvd$d * t(msvd$u)))
	}
}


# Nullspace computation
nullspace <- function(Aeq)
{
	m <- nrow(Aeq)
	n <- ncol(Aeq)
	R <- svd(Aeq,nv=n)
	U <- R$u
	V <- R$v
	S <- R$d
	if (m>1){
		s <- diag(S)
	}else{
		if (m==1){
			s <- S[1]
		}else{
			s <- 0
		}
	}
	tol <- max(m,n) * max(s) * ( .Machine$double.eps )
	r <- sum(s > tol)
	Z <- V[,(r+1):n]
	return(Z)
}


# Small singular values decomposition
psmall.svd <- function (m, tol) 
{
	B = crossprod(m)
	s = svd(B, nu = 0)
	if (missing(tol)) 
		tol = dim(B)[1] * max(s$d) * .Machine$double.eps
	Positive = s$d > tol
	d = sqrt(s$d[Positive])
	v = s$v[, Positive, drop = FALSE]
	u = m %*% v %*% diag(1/d, nrow = length(d))
	return(list(d = d, u = u, v = v))
}


# Fast singular values decomposition
fast.svd <- function (m, tol)
{
	n = dim(m)[1]
	p = dim(m)[2]
	EDGE.RATIO = 2
	if (n > EDGE.RATIO * p) {
		return(psmall.svd(m, tol))
	}
	else if (EDGE.RATIO * n < p) {
		return(nsmall.svd(m, tol))
	}
	else {
		return(positive.svd(m, tol))
	}
}


# Positive singular values decomposition
positive.svd <- function (m, tol) 
{
	s = svd(m)
	if (missing(tol)) 
		tol = max(dim(m)) * max(s$d) * .Machine$double.eps
	Positive = s$d > tol
	return(list(d = s$d[Positive], u = s$u[, Positive, drop = FALSE], 
					v = s$v[, Positive, drop = FALSE]))
}


# Build umatrix (ordinates of the value functions)
buildUmatrix <- function(u,segs)
{
	N = length(segs)
	um	= matrix(nrow=N,ncol=max(abs(as.numeric(segs)))+1)
	for (i in 1:N){
		if (i==1){
			startindex <- 1
		}else{
			startindex <- sum(abs(as.numeric(segs[1:(i-1)]))+1)+1
		}
		
		um[i,1:(abs(as.numeric(segs[i]))+1)] <- u[startindex:(startindex+abs(as.numeric(segs[i])))]
	}
	rownames(um)=names(segs)
	return( round(um,digits=5) )
}


# Creates XML tree for the output of value functions
saveUtilityFunctionUnderXML <- function( sol )
{
	z = newXMLNode("xmcda:XMCDA", namespace = c(xsi="http://www.w3.org/2001/XMLSchema-instance",xmcda="http://www.decision-deck.org/2009/XMCDA-2.0.0"))
	
	criteriaIDs <- rownames(sol$gmatrix)
	criteria = newXMLNode("criteria",attrs=c("mcdaConcept"="criteria","name"=sol$filename))
		gmatrix  <- sol$gmatrix
		umatrix  <- sol$umatrix
		for (i in 1:nrow(gmatrix)){
			id = criteriaIDs[i]
			indGrow = which(rownames(gmatrix)==id)
			indUrow = which(rownames(umatrix)==id)
			criterion  = newXMLNode("criterion",attrs=c("id"=id), parent=criteria)
			criterionFunction = newXMLNode("criterionFunction",parent=criterion)
			points = newXMLNode("points", parent=criterionFunction)
			
			for (j in 1:length(gmatrix[i,])){
				if(!is.na(gmatrix[i,j])){
					point = newXMLNode("point", parent=points)
					abscissa = newXMLNode("abscissa", parent=point)
					real = newXMLNode("real",gmatrix[indGrow,j], parent=abscissa)
					ordinate = newXMLNode("ordinate", parent=point)
					real = newXMLNode("real",umatrix[indUrow,j], parent=ordinate)
				}
			}
		}
	
	addChildren(z, criteria)

	return(z)
}


##
alreadyDone <- function( donepairs , pair )
{
	if( is.null(donepairs) ){ 
		return(FALSE) 
	}
	if( nrow(donepairs) == 0 ){ 
		return(FALSE) 
	}
	
	for( i in 1:nrow(donepairs) )
	{
		if( all(donepairs[i,1:2] == pair[1:2]) )
		{
			return(TRUE)
		}
	}
	return(FALSE)
}

##
extractSubsets <- function( nA , n ) 
{
	A <- seq( from=1 , to=nA , by=1 ) 
	matr <- matrix(ncol=n,nrow=0)
	m <- seq( from=1 , to=n , by=1 )
	j <- n
	
	while( m[j] < nA+j-n+1 )
	{
		matr <- rbind( matr , m )
		
		if( m[j] < nA+j-n && j < n )
		{
			j <- j+1
		}
		
		while( j > 1 && m[j] == nA+j-n )
		{
			j <- j - 1
			for( l in (j+1):n ) 
			{
				m[l] <- m[j]+1+l-j
			}
		}
		m[j] <- m[j]+1
	}
	rownames(matr) = NULL
	return(matr)
}

##
restrictPerformanceTable <- function(content)
{
	
	perfTable = content$performanceTable
	PT = matrix(ncol=ncol(perfTable),nrow=0)
	colnames(PT) = colnames(perfTable)
		err <- try({
				nams <- c()
				if( !is.null(content$alternativesPreferences) ){
					nams <- c( nams , content$alternativesPreferences[,1] , content$alternativesPreferences[,2] )
				}
				if( !is.null(content$alternativesIndifferences) ){
					nams <- c( nams , content$alternativesIndifferences[,1] , content$alternativesIndifferences[,2] )
				}
				
				for( i in seq(from=1,by=1,to=nrow(perfTable)) ){
					currentname = rownames(perfTable)[i]
					if( any(nams == currentname) ){
						PT = rbind(PT, perfTable[i,])
						rownames(PT)[nrow(PT)] = currentname
						}
					}
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error while restricting performanceTable" ) )
	}

	return(PT)
}

generateUtilities <- function( nbcrit, nbnodes )
{
  
  U = list()
  
  if(nbnodes < 1){nbnodes = 1}
 
  nbnodes = nbnodes + 1

  U$gmatrix = matrix( 0, nrow = nbcrit, ncol=nbnodes )
  U$umatrix = matrix( 0, nrow = nbcrit, ncol=nbnodes )
  
  for( i in c(1:nbcrit) )
  {
  	  U$gmatrix[i,] <- seq(from=0,by=(1/(nbnodes-1)), to=1)
      U$gmatrix[i,nbnodes] = 1
  	  if( nbnodes > 2){
  	  	for( j in 2:(nbnodes-1) ){
  	        U$umatrix[i,j] = U$umatrix[i,j-1] + ( (j/nbnodes) - U$umatrix[i,j-1] )*runif(1)
  	  	}}
  	  U$umatrix[i,nbnodes] = max(U$umatrix[i,nbnodes-1],0.05) + ( 1 - max(U$umatrix[i,nbnodes-1],0.10) )*runif(1)
  }

  unormfactor = sum(U$umatrix[,nbnodes])
  
  U$umatrix = U$umatrix / unormfactor
  #print(U$umatrix)
  return(U)
}

computeranking <- function( perfTable, gmatrix, umatrix )
{
  normPerfTable = computeNormalizedPerformanceTable(perfTable,gmatrix,umatrix)

  ranking = cbind( c(1:nrow(normPerfTable)), rep(0,nrow(normPerfTable) ) )
  for( i in c(1:nrow(normPerfTable)) )
  {
  	ranking[i,2] = sum(normPerfTable[i,])
  }
  
  ranking[,2] = order(ranking[,2],decreasing=TRUE)
  rownames(ranking) = rownames(normPerfTable)
  
  return(ranking)
}

generateStandardAlternatives <- function( n, p )
{
	
	P = matrix( 0, ncol=n, nrow=p**n )
	dx = 1/(p+1)
	s = seq( from=dx, to=1-dx, by=dx )
	
	if( n == 1 )
	{
		P = as.matrix(s)
	}
	
	if( n > 1 )
	{
		for( j in 1:p )
  		{
  			sf = p**(n-1)
  			P[ ((j-1)*sf+1):(j*sf) , 1 ] = s[j]
  			P[ ((j-1)*sf+1):(j*sf) , 2:n ] = generateStandardAlternatives( n-1, p )
  		}	
	}
		
	colnames(P) = 1:n
	rownames(P) = 1:(p**n)
		
	return(P)	
}

generateRandomAlternatives <- function( n, p )
{
	P = matrix( 0, ncol=n, nrow=p )	
	for(i in seq(1,p) ){
			
		dominated = TRUE
		while(dominated == TRUE){
			temp = runif(n)
			if(i==1){break}
			token1 = TRUE   # >
			token2 = TRUE	# <
			for( j in 1:(i-1) ){
				for( k in 1:n ){
					if( P[j,k] <=  temp[k] ){token1 =FALSE}
					if( P[j,k] >=  temp[k] ){token2 =FALSE}
				}
				if(token1 == TRUE || token2 == TRUE){
					#print("DOMINATION!")
					#print(P)
					#print(temp)
					#print("++++++++++++++++++++")
					break
				}
				dominated = FALSE
				break
			}
		}	
		
		P[i,1:n] = temp
	}		
	colnames(P) = 1:n
	rownames(P) = 1:p

	return(P)	
}

initializeModel <- function( A, alpha )
{
  M = list()
  M$nalt = nrow(A)
  M$nbcrit = ncol(A)
  M$nbnodes = alpha	
  M$delta = 0.0001
  M$combins = extractSubsets(nrow(A),2)
  M$orientedSegment = rep(M$nbnodes,M$nbcrit)
  names(M$orientedSegment) = c(1:M$nbcrit)
  M$segmentation = TRUE
  M$alternativesPreferences = matrix(nrow=0,ncol=3)
  M$alternativesIndifferences = matrix(nrow=0,ncol=3)
  M$alternativesRanking = matrix(nrow=0,ncol=3)
  M$initialPerformanceTable = A
  M$gmatrix = matrix(0,ncol=(alpha+1),nrow=ncol(A))
  if( alpha == 1 ){ M$gmatrix[,2]=rep(1,ncol(A)) }else{
  for( i in 1:ncol(A) ){
  	M$gmatrix[i,] <- seq(from=0,by=(1/(alpha)), to=1)
  	}}
  rownames(M$gmatrix) = c(1:M$nbcrit)
  M$necess = matrix(ncol=2,nrow=0)
  matrices <- computeEmptyUTASTARmatrices( M$orientedSegment )
  M$A <- matrices$A
  M$b <- matrices$b
  M$Aeq <- matrices$Aeq
  M$beq <- matrices$beq
  M$segs <- matrices$segs 
  
  return(M)
}

nextpair_random <- function( L )
{
	sel = 1+round((nrow(L)-1)*runif(1))
	return( list("pos"=sel, "pair"=L[sel,] ) )
}

updateModel <- function( M, nextpair, U )
{
	Mn = M
	n = M$nbcrit
	
	a1 = nextpair[seq(1,n)]
	a2 = nextpair[seq(n+1,2*n)]
	PT = rbind( a1, a2 )
	rownames(PT)=c(1,2)
	colnames(PT)=1:n
	
	nPT = computeNormalizedPerformanceTable(PT,U$gmatrix,U$umatrix)
	ua1 = sum(nPT[1,])
	ua2 = sum(nPT[2,])
	
	eq = computeequation(a1,a2,Mn)
	
	if( ua1 > ua2 ){ 	
		Mn$A = rbind(Mn$A, eq)
		Mn$b = c(Mn$b,M$delta)
		}
	if( ua2 > ua1 ){ 	
		Mn$A = rbind(Mn$A, -eq)
		Mn$b = c(Mn$b,M$delta)
		}
	if( ua1 == ua2 ){ 	
		Mn$Aeq = rbind(Mn$Aeq, eq)
		Mn$beq = c(Mn$beq,0)
		}
		
	temp = computeNecessaryRelation(Mn, Mn$necess)
	Mn$necess = temp$necess 
	Mn$combins = temp$combins
	

	return(Mn)
}


computeAlternativesIndicator <- function( M, nextpair )
{
	n = M$nbcrit
	A = M$initialPerformanceTable
	
	a1 = nextpair[seq(1,n)]
	a2 = nextpair[seq(n+1,2*n)]
	PT = rbind( a1, a2 )
	rownames(PT)=c(1,2)
	colnames(PT)=1:n
	
	eq = computeequation(a1,a2,M)
	
	Mn = M
	Mn$A = rbind(Mn$A, eq)
	Mn$b = c(Mn$b,M$delta)
	necess1 = computeNecessaryRelation(Mn, Mn$necess)
	
	Mn = M
	Mn$A = rbind(Mn$A, -eq)
	Mn$b = c(Mn$b,M$delta)
	necess2 = computeNecessaryRelation(Mn, Mn$necess)
				
	return(min(necess1$card,necess2$card))
}


computeEmptyUTASTARmatrices <- function( prefDirections )
{
		
	# début de la construction
	err <- try({
				# nbre de critères
				Ncrit = length( prefDirections )
				
				S <- sum( abs( as.numeric(prefDirections) ) )
				
				
				V <- S + Ncrit
				
				A <- matrix(0,nrow=S,ncol=V)
				b <- matrix(0,nrow=S,ncol=1)
				
				Aeq = matrix(0,nrow=Ncrit+1,ncol=V)
				beq = matrix(0,nrow=Ncrit+1,ncol=1)
				
	
				
				for ( i in 1:Ncrit ){
						if (i==1){
							x <- 0
							y <- 0
						}else{
							x <- sum(abs(as.numeric(prefDirections[1:(i-1)])))+i-1
							y <- sum(abs(as.numeric(prefDirections[1:(i-1)])))
						}
						
						s <- sign(as.numeric(prefDirections[i]))
						if( s != 0 ){
							for (j in (1:abs(as.numeric(prefDirections[i])))){
								A[y+j,x+j] <- -s
								A[y+j,x+j+1] <- s
							}
						}
					}
				
				for (i in 1:Ncrit){
					y=i
					if(i==1)
					{
						infe <- 1
					}
					else
					{
						infe <- sum(abs(as.numeric(prefDirections[1:(i-1)])))+i
					}
					supe <- sum(abs(as.numeric(prefDirections[1:i])))+i
					if (sign(as.numeric(prefDirections[i]))>0)
					{
						Aeq[y,infe]=1
						Aeq[Ncrit+1,supe]=1
					}
					else
					{
						Aeq[y,supe]=1
						Aeq[Ncrit+1,infe]=1
					}
				}
				beq[Ncrit+1]=1
				
				
				b <- as.vector(b)
				beq <- as.vector(beq)
				
				c <- matrix(1,nrow=1,ncol=V)
				c[1,1:(Ncrit+S)]=0
				c <- as.vector(c)
			})
	if (inherits(err, "try-error") ){
		return( list( "validation"=FALSE , "LOG"="error during computation of UTASTAR raw constraints" ) )
	}
	
	return( list( "A"=A , "b"=b , "Aeq"=Aeq , "beq"=beq , "segs"=prefDirections , "validation"=TRUE ) )
}


updateLearningSet <- function( L, M, pos )
{
	n = ncol(L)/2
	newL = matrix(ncol=2*n,nrow=0)
	PT = round( M$initialPerformanceTable , digits = 5 )
	L = round( L , digits = 5 )
	
	for( i in 1:nrow(L) ){
		for( j in 1:nrow(PT)){
			if( all(L[i,1:n] == PT[j,1:n]) ){ a1 = j }
			if( all(L[i,(n+1):(2*n)] == PT[j,1:n]) ){ a2 = j }
			}
		if(	i != pos
			&&
			!alreadyDone(M$necess, c(a2,a1)) 
			&&
			!alreadyDone(M$necess, c(a2,a1))  )
			{
				newL = rbind( newL, L[i,] )	
			}
		}
		
	return(newL)	
}


computeequation <- function( a1, a2, M )
{
    gmatrix = M$gmatrix
    performanceTable = M$initialPerformanceTable
    segs = M$orientedSegment
    nC = nrow(gmatrix)
    nnn = sum(abs(as.numeric(segs)))
    Ncrit = nC
    equ = rep(0,nC+nnn)
    
						
    for( j in 1:Ncrit ){		
		
		crit <- names(segs)[j]
							
		jPT <- which( colnames(performanceTable) == crit )
		g <- gmatrix[ which( rownames(gmatrix) == crit ) , ]
										
		ga <- a1[jPT]
		gb <- a2[jPT]

		gainfind <- max(which(g<=ga))
		gasupind <- min(which(g>=ga))
		gbinfind <- max(which(g<=gb))
		gbsupind <- min(which(g>=gb))
	
		gainf <- g[gainfind]
		gasup <- g[gasupind]
		gbinf <- g[gbinfind]
		gbsup <- g[gbsupind]
	
		if (j == 1){ x <- 0 }else{
		    x <- sum(abs(as.numeric(segs[1:(j-1)]))) +j-1
		}
	
		if (gainf == gasup) {
		    equ[x+gainfind] <- equ[x+gainfind]+1
		}else{
		    equ[x+gainfind] <- equ[x+gainfind]+ (gasup-ga)/(gasup-gainf)
		    equ[x+gasupind] <- equ[x+gasupind]+ (ga-gainf)/(gasup-gainf)
		}
	
		if (gbinf == gbsup) {
		    equ[x+gbinfind] <- equ[x+gbinfind]-1
		}else{
		    equ[x+gbinfind] <- equ[x+gbinfind] - (gbsup-gb)/(gbsup-gbinf)
		    equ[x+gbsupind] <- equ[x+gbsupind] - (gb-gbinf)/(gbsup-gbinf)
		}
    }

    return(equ)
}


computeNecessaryRelation <- function(M, previousNecess)
{
	if( is.null(previousNecess) ){
		updatedNecess = matrix(ncol=2,nrow=0)
	}else{updatedNecess = previousNecess}
	
	possiblepairs = M$combins
	newcombins = matrix(ncol=2,nrow=0)
	
	PT = M$initialPerformanceTable
	
	if(nrow(possiblepairs)==0){
		updatedNecess = previousNecess
		card = nrow(updatedNecess) 
		return(list("card"=card,"necess"=updatedNecess,"combins"= newcombins))
		}
	
	for( i in seq(from=1,to=nrow(possiblepairs)) ){

		a1 = possiblepairs[i,1]
		a2 = possiblepairs[i,2]
		
		added = FALSE
		
		#if(!alreadyDone(updatedNecess, c(a1,a2)) 
		#	&& !alreadyDone(M$alternativesPreferences, c(a1,a2))
		#	){

			A <- M$A
			b <- M$b
			Aeq <- M$Aeq
			beq <- M$beq
			cd <- M$c
			segs <- M$orientedSegment
			gmatrix <- M$gmatrix
			
			uy=c(rep(">=",length(b)),rep("==",length(beq)))
				
			cc = computeequation( PT[a1,], PT[a2,], M )

			d <- c( rep(">=",length(b)) , rep("==",length(beq)) )
						
			u1 <- lp( "min" , cc , rbind(A,Aeq) , d , c(b,beq) )
			
			if( cc %*% u1$solution >= 0 ){
				updatedNecess = rbind(updatedNecess,c(a1,a2))
				added = TRUE
			}

		#}
		if( added == FALSE ){
		# && !alreadyDone(updatedNecess, c(a2,a1))  
		#	&& !alreadyDone(M$alternativesPreferences, c(a2,a1))
		#	){
		
				
			A <- M$A
			b <- M$b
			Aeq <- M$Aeq
			beq <- M$beq
			cd <- M$c
			segs <- M$orientedSegment
			gmatrix <- M$gmatrix
			
			uy=c(rep(">=",length(b)),rep("==",length(beq)))

			cd = rep(0,length(cd))

			cc = computeequation( PT[a2,], PT[a1,], M )
			
			d <- c( rep(">=",length(b)) , rep("==",length(beq)) )
						
			u2 <- lp( "min" , cc , rbind(A,Aeq) , d , c(b,beq) )
			
			if( cc %*% u2$solution >= 0 ){
				updatedNecess = rbind(updatedNecess,c(a2,a1))
				added = TRUE
			}
		}
		if( added == FALSE ){
			newcombins = rbind( newcombins, c(a1,a2) )
		}
	}	

	rownames(newcombins) = NULL
	card = nrow(updatedNecess)	
	
	return(list("card"=card,"necess"=updatedNecess,"combins"= newcombins))
}


getRanking <- function( M )
{
	P = M$initialPerformanceTable
	N <- length(as.numeric(M$orientedSegment))
  	S <- sum(abs(as.numeric(M$orientedSegment)))
  	M$cd = rep(0,ncol(M$A))
  	M$cd[seq(from=S+N,to=ncol(M$A))]
  	
	x <- solveUTASTAR( M$cd , M$A , M$Aeq , M$b , M$beq , N )
    u = x$x

    M$A <- -M$A
    M$b <- -M$b
    res <- analyticCenter( u[1:(S+N)] , M$A[,1:(S+N)] , M$b , M$Aeq[,1:(S+N)] )
	
  	xac = res$x
  
	umatrix = buildUmatrix(t(xac),M$orientedSegment)
	#print(M$gmatrix)
	#print(umatrix)
	NPT = computeNormalizedPerformanceTable(P,M$gmatrix,umatrix)
	ranking = matrix(0,ncol=2,nrow=nrow(P))
	ranking[,1]=rownames(P)
	for( i in seq(1,nrow(NPT))){
		ranking[i,2] = sum(NPT[i,])
	}
	or = order(ranking[,2],decreasing=TRUE)
	ranking[,1]=ranking[or,1]
	ranking[,2]=ranking[or,2]
	
	ranking = computeranking( P, M$gmatrix, umatrix )
	return(list("acranking"= ranking,"uac"=xac))
}


computeUtilitiesIndicator <- function(M)
{
	sol = 0
	bounds = rep( 1, ncol(M$A) )
	
	for( i in (1:M$nbcrit) )
	{
		for( l in (2:(M$nbnodes+1)) )
		{
			bounds[((i-1)*(M$nbnodes+1))+l] = computebound( M, i, l )
		}
	}
	sol = round(prod(bounds),digits=4)
	ind = seq(from=1,by=M$nbnodes+1,to=M$nbcrit*(M$nbnodes+1))
	#bounds[ind]=0
	#print(c("Bounds : ",bounds))
	#print(sol)
	
	return(sol)	
}

computeUtilitiesIndicator_weights <- function(M)
{
	sol = 0
	bounds = rep( 1, ncol(M$A) )
	
	for( i in (1:M$nbcrit) )
	{
		#for( l in (2:(M$nbnodes+1)) )
		#{
			l = M$nbnodes+1
			bounds[((i-1)*(M$nbnodes+1))+l] = computebound( M, i, l )
		#}
	}
	sol = round(prod(bounds),digits=4)
	ind = seq(from=1,by=M$nbnodes+1,to=M$nbcrit*(M$nbnodes+1))
	
	return(sol)	
}

computebound <- function( M, i, l )
{
	
	nbcrit = M$nbcrit
	alpha = M$nbnodes
	
	A <- M$A
	b <- M$b
	Aeq <- M$Aeq
	beq <- M$beq
	segs <- M$orientedSegment
	gmatrix <- M$gmatrix
	
	nnn = nbcrit*(alpha+1)
	cd = rep(0,ncol(A))
	
	cd[ ((i-1)*(M$nbnodes+1))+l ] = 1
	#print("cd")
	#print(cd)
	
	d <- c( rep(">=",length(b)) , rep("==",length(beq)) )
	u1 <- lp( "min" , cd , rbind(A,Aeq) , d , c(b,beq) )
	x1 <- u1$solution[ ((i-1)*(M$nbnodes+1))+l  ]
	u2 <- lp( "max" , cd , rbind(A,Aeq) , d , c(b,beq) )
	x2 <- u2$solution[ ((i-1)*(M$nbnodes+1))+l  ]

	return(x2-x1)
}

comparerankings <- function( ranking1, ranking2 )
{
  badpairs = 0
  N = nrow(ranking1)
  
  for( i in c(1:(N-1)) )
  {
  	r11 = ranking1[which(ranking1[,1]==i),2]
  	r21 = ranking2[which(ranking2[,1]==i),2]
  	for( j in c((i+1):N) )
  	{
  	  r12 = ranking1[which(ranking1[,1]==j),2]
  	  r22 = ranking2[which(ranking2[,1]==j),2]
  	  
  	  if( 
  	  	( ( r11 >= r12 ) && ( r21 <= r22 ) )
  	  	||
  	  	( ( r11 <= r12 ) && ( r21 >= r22 ) )
  	  	)
  	  {
  	  	badpairs = badpairs + 1
  	  }
  	}
  }
  
  return(badpairs)
}


nextpair_volumeoriented <- function( L, M )
{
	n = ncol(L)/2	
	perfs = matrix(ncol=2,nrow=0)
	
	for( i in seq(1,nrow(L)) ){
		
		a1 = L[i,seq(1,n)]
		a2 = L[i,seq(n+1,2*n)]
		
		### x > y
		Mb = M
		constraint = computeequation(a1,a2,Mb)
		Mb$A = rbind(M$A, constraint) 
		Mb$b = c(M$b,M$delta)
		rownames(Mb$A)=NULL
		bounds1 = computeUtilitiesIndicator(Mb)
		
		### y > x
		Mb = M
		Mb$A = rbind(M$A, -constraint) 	
		Mb$b = c(M$b,M$delta)
		rownames(Mb$A)=NULL
		bounds2 = computeUtilitiesIndicator(Mb)
		
		
		### aggreg
		perf = c(i, max(bounds1, bounds2))
		perfs = rbind( perfs, perf )
		rownames(perfs)=NULL
		
	}
	
	goodpairs = which( perfs[,2]==min(perfs[,2]))
	Lbis = L[goodpairs,]
	
	if( is.vector(Lbis) ){
		pair = Lbis
		pos = goodpairs
	}else{
		perfsBis = matrix(ncol=2,nrow=0)
		for( i in seq(1,nrow(Lbis)) ){
			temp = computeAlternativesIndicator(M, Lbis[i,])
			perfsBis = rbind( perfsBis, c(i,temp) )
			#print(c(i,nrow(Lbis)))
		}
		goodpairsBis = which( perfsBis[,2]==max(perfsBis[,2]))

		pair = Lbis[goodpairsBis[1],]
		pos = goodpairs[goodpairsBis[1]]
	}
	
	return(list("pair"=pair,"pos"=pos))	
}

nextpair_relationoriented <- function( L, M )
{
	n = ncol(L)/2	
	perfs = matrix(ncol=2,nrow=0)
	
	for( i in seq(1,nrow(L)) ){
		temp = computeAlternativesIndicator(M, L[i,])
		perfs = rbind( perfs, c(i,temp) )
		rownames(perfs)=NULL
	}
	
	print("/")
	
	goodpairs = which( perfs[,2]==max(perfs[,2]))
	Lbis = L[goodpairs,]
	
	if( is.vector(Lbis) ){
		pair = Lbis
		pos = goodpairs
	}else{
		perfsBis = matrix(ncol=2,nrow=0)	
		
		for( i in seq(1,nrow(Lbis)) ){
		
			a1 = Lbis[i,seq(1,n)]
			a2 = Lbis[i,seq(n+1,2*n)]
		
			### x > y
			Mb = M
			constraint = computeequation(a1,a2,Mb)
			Mb$A = rbind(M$A, constraint) 
			Mb$b = c(M$b,M$delta)
			rownames(Mb$A)=NULL
			bounds1 = computeUtilitiesIndicator(Mb)
			
			### y > x
			Mb = M
			Mb$A = rbind(M$A, -constraint) 	
			Mb$b = c(M$b,M$delta)
			rownames(Mb$A)=NULL
			bounds2 = computeUtilitiesIndicator(Mb)
		
			### aggreg
			perf = c(i, max(bounds1, bounds2))
			perfsBis = rbind( perfsBis, perf )
			rownames(perfsBis)=NULL
		
		}
		goodpairsBis = which( perfsBis[,2]==min(perfsBis[,2]))

		pair = Lbis[goodpairsBis[1],]
		pos = goodpairs[goodpairsBis[1]]
	}
	
	return(list("pair"=pair,"pos"=pos))	
}


nextpair_visionary <- function( L, M, U )
{
	perfs = matrix(ncol=2,nrow=0)
	n = ncol(L)/2
	A = M$initialPerformanceTable
	for( i in 1:nrow(L)){
		PT = rbind( L[i,1:n],L[i,(n+1):(2*n)] )
		rownames(PT)=c(1,2)
		colnames(PT)=1:ncol(A)
		nPT = computeNormalizedPerformanceTable(PT,U$gmatrix,U$umatrix)
		ua1 = sum(nPT[1,])
		ua2 = sum(nPT[2,])
		eq = computeequation(L[i,1:n],L[i,(n+1):(2*n)],M)
		Mn = M
		if( ua1 > ua2 ){ 	
			Mn$A = rbind(Mn$A, eq)
			Mn$b = c(Mn$b,M$delta)
		}
		if( ua2 > ua1 ){ 	
			Mn$A = rbind(Mn$A, -eq)
			Mn$b = c(Mn$b,M$delta)
		}
		if( ua1 == ua2 ){ 	
			Mn$Aeq = rbind(Mn$Aeq, eq)
			Mn$beq = c(Mn$beq,0)
		}	
		temp = computeNecessaryRelation(Mn, M$necess)
		perfs = rbind( perfs, c(i,temp$card) )
	}
			
	goodpairs = which( perfs[,2]==max(perfs[,2]))
	Lbis = L[goodpairs,]
	
	if( is.vector(Lbis) ){
		pair = Lbis
		pos = goodpairs
	}else{
		selected = nextpair_random( Lbis )
		pair = selected$pair
		pos = goodpairs[selected$pos]
	}
	
	return(list("pair"=pair,"pos"=pos))		
}


generateEasyLearningSet <- function( M )
{
	library(lpSolve)
	res = getRanking(M)
	uac = res$uac
	nbcrit = M$nbcrit
	alpha = M$nbnodes
	L = matrix(nrow=0,ncol=2*nbcrit)
	segs = rep(alpha,nbcrit)
	critPossibs = extractSubsets(nbcrit,2)
	
	for( i in 1:nrow(critPossibs) )
	{
		for( pos11 in 1:alpha ){
		for( pos12 in 1:alpha ){
		for( pos21 in 1:alpha ){
		for( pos22 in 1:alpha ){
			x = runif(nbcrit)
			crit1 = critPossibs[i,1]
			crit2 = critPossibs[i,2]
			x[crit1] = M$gmatrix[crit1,pos11] + ( M$gmatrix[crit1,pos11+1] - M$gmatrix[crit1,pos11] )*runif(1)
			x[crit2] = M$gmatrix[crit2,pos12] + ( M$gmatrix[crit2,pos12+1] - M$gmatrix[crit2,pos12] )*runif(1)
			cx = findcprofile(M$gmatrix, x)
			cy = generateYprofileFromX( segs, c(crit1,crit2),c(pos11,pos12),c(pos21,pos22), cx,uac)
			y = invertprofile(M$gmatrix, cy )
			ysol = testeasypair( verbose=FALSE, x, y, cx, cy, M$gmatrix, uac, c(crit1,crit2), c(pos11,pos12), c(pos21,pos22) )
			if( !all(y==0) && !all(round(y-x,digits=3)==0) ){
				if( !is.null(ysol) ){
					L = rbind(L, c(x,ysol))
				}	
			}
		}}}}
	}
	
	return(L)	
}

findcprofile <- function( gmatrix, alt, segs=NULL )
{
    Ncrit = nrow(gmatrix)
    if(is.null(segs)){ segs = rep(ncol(gmatrix)-1,Ncrit) }
    equ = rep(0,Ncrit+sum(abs(as.numeric(segs))))
    for( j in 1:Ncrit ){	
		g <- gmatrix[j, ]
		ga <- alt[j]
		gainfind <- max(which(g<=ga))
		gasupind <- min(which(g>=ga))
		gainf <- g[gainfind]
		gasup <- g[gasupind]
		if (j == 1){ x <- 0 }else{
		    x <- sum(abs(as.numeric(segs[1:(j-1)]))) +j-1
		}
		if (gainf == gasup) {
		    equ[x+gainfind] <- equ[x+gainfind]+1
		}else{
		    equ[x+gainfind] <- equ[x+gainfind]+ (gasup-ga)/(gasup-gainf)
		    equ[x+gasupind] <- equ[x+gasupind]+ (ga-gainf)/(gasup-gainf)
		}
    }
    return(equ)
}

invertprofile <- function( gmatrix, u, segs=NULL )
{
    Ncrit = nrow(gmatrix)
    if(is.null(segs)){ segs = rep(ncol(gmatrix)-1,Ncrit) }
    alt = rep(0,Ncrit)
    
    for( j in 1:Ncrit )
    {
    	if( j == 1 ){ start = 1 }
    	else{ start = j + sum(abs(as.numeric(segs[1:j-1]))) }
    	end = j + sum(abs(as.numeric(segs[1:j])))
    	alt[j] = sum( gmatrix[j,] * u[start:end] )
    }    
    return(alt) 
}


generateYprofileFromX <- function( segs, crits, poss1, poss2, cx, upoint)
{
	
	crit1 = crits[1]
	crit2 = crits[2]
	pos11 = poss1[1]
	pos12 = poss1[2]
	pos21 = poss2[1]
	pos22 = poss2[2]
	
	if( (pos11 > pos21 && pos12 > pos22) ||
		pos11 < pos21 && pos12 < pos22 ){ return(NULL) }
	
	A = matrix(ncol=4, nrow=0)
	Aeq = matrix(ncol=4, nrow=0)
	b = c()
	beq = c()
	
	Aeq = rbind( Aeq , c(1,1,0,0) )
	beq = c( beq, 1 )
	Aeq = rbind( Aeq , c(0,0,1,1) )
	beq = c( beq, 1 )
	dir = c()
	
	if( crit1 == 1 ){ start1=0 }
	else{ start1 = crit1-1 + sum(abs(as.numeric(segs[1:(crit1-1)]))) }
	if( crit2 == 1 ){ start2=0 }
	else{ start2 = crit2-1 + sum(abs(as.numeric(segs[1:(crit2-1)]))) }
	
	temp = c(upoint[start1+pos21],upoint[start1+pos21+1],upoint[start2+pos22],upoint[start2+pos22+1])
	Aeq = rbind( Aeq , temp )
	
	seg1 = abs(as.numeric(segs[crit1]))
	seg2 = abs(as.numeric(segs[crit2]))
	range1 = (start1+1):(start1+seg1+1)
	range2 = (start2+1):(start2+seg2+1)	
	#print(range1)
	#print(range2)

	temp = cx[range1] %*% upoint[range1] + cx[range2] %*% upoint[range2]
	beq = c( beq, temp )
	
	#A = diag(4)
	#b = rep(1,4)
	#dir = c( rep("<=",4) )
	if( pos11 == pos21 ){ 
		if( pos12 < pos22 ){
			A = rbind( A, c(0,1,0,0) )
			b = c(b, cx[start1+pos21+1] )
			dir = c( dir, "<" )
		}
		if( pos12 >= pos22 ){
			A = rbind( A, c(0,1,0,0) )
			b = c(b, cx[start1+pos21+1] )
			dir = c( dir, ">" )
		}
	}
	if( pos12 == pos22 ){ 
		if( pos11 <= pos21 ){
			A = rbind( A, c(0,0,0,1) )
			b = c(b, cx[start2+pos22+1] )	
			dir = c( dir, "<" )
		}
		if( pos11 > pos21 ){
			A = rbind( A, c(0,0,0,1) )
			b = c(b, cx[start2+pos22+1] )	
			dir = c( dir, ">" )
		}

	}
	
	
	dir = c( dir, rep("=",nrow(Aeq)) )
	obj = c(-1,1,-1,1)
	library(lpSolve)
	sol = lp( dir="min", objective.in=obj, const.mat=rbind(A,Aeq), const.dir=dir, const.rhs=c(b,beq))
	
	#print(sol)
	if( sol$status != 0 ){ 
		#print(cbind(A,b))
		#print(cbind(Aeq,beq))
		return(NULL) }
	sol = sol$solution
		
	cy = cx
	cy[range1] = rep(0,length(range1))
	cy[range2] = rep(0,length(range2))
	cy[start1+pos21] = sol[1]
	cy[start1+pos21+1] = sol[2]
	cy[start2+pos22] = sol[3]
	cy[start2+pos22+1] = sol[4]
	
	#print(cy)
	return(cy)
}

checkEasyPair <- function( verbose, x, y, cx, cy, gmatrix, upoint, crits, poss1, poss2 )
{
	crit1 = crits[1]
	crit2 = crits[2]
	pos11 = poss1[1]
	pos12 = poss1[2]
	pos21 = poss2[1]
	pos22 = poss2[2]
	
	
	if( (y[crit1] > 1) || (y[crit1] < 0) )
	{ if(verbose==TRUE){ print("y[crit1] NOT BOUNDED") }
		return(NULL) }
	if( (y[crit2] > 1) || (y[crit2] < 0) )
	{ if(verbose==TRUE){ print("y[crit2] NOT BOUNDED") }
		return(NULL) }
	
	if( (x[crit1] >= y[crit1]) && (x[crit2] >= y[crit2]) )
	{ if(verbose==TRUE){ print("x DOMINATES y") } 
		return(NULL) }
	if( (x[crit1] <= y[crit1]) && (x[crit2] <= y[crit2]) )
	{ if(verbose==TRUE){ print("y DOMINATES x") }
		return(NULL) }	

	if( (y[crit1] < gmatrix[crit1,pos21]) || (y[crit1] > gmatrix[crit1,pos21+1]) )
	{ if(verbose==TRUE){ print("y[crit1] NOT IN THE CORRECT SEGMENT") }
		return(NULL) }

	if( (y[crit2] < gmatrix[crit2,pos22]) || (y[crit2] > gmatrix[crit2,pos22+1]) )
	{ if(verbose==TRUE){ print("y[crit2] NOT IN THE CORRECT SEGMENT") }
		return(NULL) }

	if(  abs((cy-cx)%*%upoint) >= 0.001 )
	{ if(verbose==TRUE){ print("DO NOT PASS THROUGH upoint") } 
		return(NULL) }
	
	#print( "OK" )
	return(y)
}
